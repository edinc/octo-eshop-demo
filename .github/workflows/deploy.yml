name: Deploy to Environment

on:
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: string
      image_tag:
        description: 'Image tag to deploy'
        required: true
        type: string
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - production
      image_tag:
        description: 'Image tag to deploy (default: latest)'
        required: false
        default: 'latest'

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    env:
      ACR_REGISTRY: ${{ secrets.ACR_LOGIN_SERVER }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment variables
        id: env
        run: |
          ENV="${{ inputs.environment }}"
          TAG="${{ inputs.image_tag || 'latest' }}"

          echo "environment=${ENV}" >> "$GITHUB_OUTPUT"
          echo "image_tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "namespace=octo-eshop-${ENV}" >> "$GITHUB_OUTPUT"

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Setup Helm
        uses: azure/setup-helm@v4

      - name: Create namespace and ACR pull secret
        run: |
          NS=${{ steps.env.outputs.namespace }}
          kubectl create namespace "${NS}" --dry-run=client -o yaml | kubectl apply -f -

          # Create ACR image pull secret
          kubectl create secret docker-registry acr-secret \
            --namespace "${NS}" \
            --docker-server="${ACR_REGISTRY}" \
            --docker-username="${{ secrets.ACR_USERNAME }}" \
            --docker-password="${{ secrets.ACR_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy services with Helm
        run: |
          ENV=${{ steps.env.outputs.environment }}
          TAG=${{ steps.env.outputs.image_tag }}
          NS=${{ steps.env.outputs.namespace }}

          # Deploy network policies first
          helm upgrade --install network-policies ./helm/charts/network-policies \
            --namespace "${NS}" --wait --timeout 2m

          # Adopt any orphaned secrets so Helm can manage them
          for service in user-service product-service cart-service order-service payment-service; do
            SECRET_NAME="${service}-secrets"
            if kubectl get secret "${SECRET_NAME}" -n "${NS}" 2>/dev/null | grep -qv "managed-by.*Helm"; then
              echo "Adopting ${SECRET_NAME} for Helm..."
              kubectl annotate secret "${SECRET_NAME}" -n "${NS}" \
                meta.helm.sh/release-name="${service}" \
                meta.helm.sh/release-namespace="${NS}" --overwrite 2>/dev/null || true
              kubectl label secret "${SECRET_NAME}" -n "${NS}" \
                app.kubernetes.io/managed-by=Helm --overwrite 2>/dev/null || true
            fi
          done

          # Deploy each service
          for service in user-service product-service cart-service order-service payment-service frontend; do
            echo "Deploying ${service}..."
            helm upgrade --install "${service}" "./helm/charts/${service}" \
              --namespace "${NS}" \
              -f "./helm/charts/${service}/values.yaml" \
              -f "./helm/charts/${service}/values-${ENV}.yaml" \
              --set "image.tag=${TAG}" \
              --set "image.repository=${ACR_REGISTRY}/${service}" \
              --set "imagePullSecrets[0].name=acr-secret" \
              --timeout 5m
          done

      - name: Override secrets with Azure values
        env:
          USER_DATABASE_URL: ${{ secrets.USER_DATABASE_URL }}
          PRODUCT_DATABASE_URL: ${{ secrets.PRODUCT_DATABASE_URL }}
          ORDER_DATABASE_URL: ${{ secrets.ORDER_DATABASE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          SERVICEBUS_CONNECTION_STRING: ${{ secrets.SERVICEBUS_CONNECTION_STRING }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          NS=${{ steps.env.outputs.namespace }}
          SVC_AUTH_TOKEN="${{ steps.env.outputs.environment }}-service-auth-token"

          apply_secret() {
            local name="$1"; shift
            kubectl create secret generic "${name}-secrets" \
              --namespace "${NS}" --dry-run=client -o yaml "$@" | kubectl apply -f -
          }

          apply_secret user-service \
            --from-literal="DATABASE_URL=${USER_DATABASE_URL}" \
            --from-literal="JWT_SECRET=${JWT_SECRET}"

          apply_secret product-service \
            --from-literal="DATABASE_URL=${PRODUCT_DATABASE_URL}"

          apply_secret cart-service \
            --from-literal="REDIS_URL=${REDIS_URL}"

          apply_secret order-service \
            --from-literal="DATABASE_URL=${ORDER_DATABASE_URL}" \
            --from-literal="SERVICEBUS_CONNECTION_STRING=${SERVICEBUS_CONNECTION_STRING}" \
            --from-literal="SERVICE_AUTH_TOKEN=${SVC_AUTH_TOKEN}"

          apply_secret payment-service \
            --from-literal="SERVICEBUS_CONNECTION_STRING=${SERVICEBUS_CONNECTION_STRING}" \
            --from-literal="SERVICE_AUTH_TOKEN=${SVC_AUTH_TOKEN}"

          # Restart deployments to pick up new secrets
          for service in user-service product-service cart-service order-service payment-service; do
            kubectl rollout restart deployment "${service}" -n "${NS}"
          done

          # Wait for rollouts
          for service in user-service product-service cart-service order-service payment-service frontend; do
            echo "Waiting for ${service}..."
            kubectl rollout status deployment "${service}" -n "${NS}" --timeout=5m || true
          done

      - name: Run database migrations and seed
        run: |
          NS=${{ steps.env.outputs.namespace }}
          ENV=${{ steps.env.outputs.environment }}

          # Run Prisma migrations for services with databases
          for service in user-service product-service order-service; do
            echo "Running database migrations for ${service}..."
            kubectl exec deployment/${service} -n "${NS}" -- npx prisma db push --skip-generate || true
          done

          # Seed product data only in dev/staging (not production to avoid data loss)
          if [ "${ENV}" != "production" ]; then
            echo "Seeding product-service database..."
            kubectl exec deployment/product-service -n "${NS}" -- npx prisma db seed || true
          else
            echo "Skipping seed in production environment"
          fi

      - name: Verify deployment
        run: |
          NS=${{ steps.env.outputs.namespace }}

          echo "=== Pods ==="
          kubectl get pods -n "${NS}"

          echo "=== Services ==="
          kubectl get services -n "${NS}"

          echo "=== Helm Releases ==="
          helm list -n "${NS}"

      - name: Run smoke tests
        run: |
          NS=${{ steps.env.outputs.namespace }}
          sleep 15

          for service in user-service product-service cart-service order-service payment-service; do
            echo "Checking ${service}..."
            kubectl get deployment "${service}" -n "${NS}" -o jsonpath='{.status.readyReplicas}' || echo "Not ready"
          done
        continue-on-error: true
