name: Deploy to Environment

on:
  repository_dispatch:
    types: [deploy]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - dev
          - staging
      image_tag:
        description: 'Image tag to deploy (default: latest)'
        required: false
        default: 'latest'

permissions:
  id-token: write
  contents: read

env:
  ACR_REGISTRY: ${{ secrets.ACR_LOGIN_SERVER }}

jobs:
  deploy:
    name: Deploy to ${{ github.event.inputs.environment || github.event.client_payload.environment }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || github.event.client_payload.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment variables
        id: env
        run: |
          ENV=${{ github.event.inputs.environment || github.event.client_payload.environment }}
          TAG=${{ github.event.inputs.image_tag || github.event.client_payload.image_tag || 'latest' }}

          echo "environment=${ENV}" >> "$GITHUB_OUTPUT"
          echo "image_tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "namespace=octo-eshop-${ENV}" >> "$GITHUB_OUTPUT"

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Setup Helm
        uses: azure/setup-helm@v4

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ steps.env.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy services with Helm
        run: |
          ENV=${{ steps.env.outputs.environment }}
          TAG=${{ steps.env.outputs.image_tag }}
          NS=${{ steps.env.outputs.namespace }}

          # Deploy network policies first
          helm upgrade --install network-policies ./helm/charts/network-policies \
            --namespace "${NS}" --wait --timeout 2m

          # Deploy each service without waiting (secrets will be overridden next)
          for service in user-service product-service cart-service order-service payment-service frontend; do
            echo "Deploying ${service}..."
            helm upgrade --install "${service}" "./helm/charts/${service}" \
              --namespace "${NS}" \
              -f "./helm/charts/${service}/values.yaml" \
              -f "./helm/charts/${service}/values-${ENV}.yaml" \
              --set "image.tag=${TAG}" \
              --set "image.repository=${ACR_REGISTRY}/${service}" \
              --timeout 5m
          done

      - name: Override secrets with Azure values
        env:
          USER_DATABASE_URL: ${{ secrets.USER_DATABASE_URL }}
          PRODUCT_DATABASE_URL: ${{ secrets.PRODUCT_DATABASE_URL }}
          ORDER_DATABASE_URL: ${{ secrets.ORDER_DATABASE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          SERVICEBUS_CONNECTION_STRING: ${{ secrets.SERVICEBUS_CONNECTION_STRING }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          NS=${{ steps.env.outputs.namespace }}
          SVC_AUTH_TOKEN="dev-service-auth-token"

          apply_secret() {
            local name="$1"; shift
            kubectl create secret generic "${name}-secrets" \
              --namespace "${NS}" --dry-run=client -o yaml "$@" | kubectl apply -f -
          }

          apply_secret user-service \
            --from-literal="DATABASE_URL=${USER_DATABASE_URL}" \
            --from-literal="JWT_SECRET=${JWT_SECRET}"

          apply_secret product-service \
            --from-literal="DATABASE_URL=${PRODUCT_DATABASE_URL}"

          apply_secret cart-service \
            --from-literal="REDIS_URL=${REDIS_URL}"

          apply_secret order-service \
            --from-literal="DATABASE_URL=${ORDER_DATABASE_URL}" \
            --from-literal="SERVICEBUS_CONNECTION_STRING=${SERVICEBUS_CONNECTION_STRING}" \
            --from-literal="SERVICE_AUTH_TOKEN=${SVC_AUTH_TOKEN}"

          apply_secret payment-service \
            --from-literal="SERVICEBUS_CONNECTION_STRING=${SERVICEBUS_CONNECTION_STRING}" \
            --from-literal="SERVICE_AUTH_TOKEN=${SVC_AUTH_TOKEN}"

          # Restart deployments to pick up new secrets
          for service in user-service product-service cart-service order-service payment-service; do
            kubectl rollout restart deployment "${service}" -n "${NS}"
          done

          # Wait for rollouts
          for service in user-service product-service cart-service order-service payment-service frontend; do
            echo "Waiting for ${service}..."
            kubectl rollout status deployment "${service}" -n "${NS}" --timeout=5m || true
          done

      - name: Verify deployment
        run: |
          NS=${{ steps.env.outputs.namespace }}

          echo "=== Pods ==="
          kubectl get pods -n "${NS}"

          echo "=== Services ==="
          kubectl get services -n "${NS}"

          echo "=== Helm Releases ==="
          helm list -n "${NS}"

      - name: Run smoke tests
        if: steps.env.outputs.environment != 'production'
        run: |
          NS=${{ steps.env.outputs.namespace }}
          sleep 15

          # Test health endpoints via port-forward
          for service in user-service product-service cart-service order-service payment-service; do
            echo "Checking ${service}..."
            kubectl get deployment "${service}" -n "${NS}" -o jsonpath='{.status.readyReplicas}' || echo "Not ready"
          done
        continue-on-error: true
